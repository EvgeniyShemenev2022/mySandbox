## Многопоточность -
принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.

### основные цели:
- производительность
- concurrency

### 1 создание 
// создание вариант 1
> class AppThread1 extends Thread{ public void run() {код} }
> 
// запуск
> appThread1.start();
>
метод run() запускается автоматически посредством JVM, при вызове метода start()

// создание вариант 2
> class AppThread implements Runnable { public void run() {код} }
>
// запуск
> new Thread(new Runnable()).start();

### 2 методы .getName() & .getPriority()
Стандартный приоритет потока - 5;  (градация от 1 до 10); 
10 - наивысший приоритет;
установить приоритет можно вручную:
- .setPriority(10);
- .setPriority(Thread.NORM_PRIORITY);


### volatile
Каждый поток работает независимо от других. При обработке данных поток копирует переменные в **CASH-CPU** (речь о
разных ядрах процессора);  
Переменная, отмеченная ключевым словом **volatile** попадает (ее значение) в общую память процессора (Main Memory);  
Корректно переменная с **volatile** работает только в том случае, если изменяет ее строго один из потоков, а остальные
лишь читают переменную;

### Data Race & synchronized methods
Когда несколько потоков имеют доступ к изменению значения переменной, то на выходе почти всегда будет неверный результат;
Это связано с разной скоростью потоков и невозможностью это спрогнозировать. Чтобы избежать ошибок, необходимо
синхронизировать потоки относительно друг друга (поставить LOCK); Функция замка в том, чтобы давать доступ к методу
**только** для одного потока в единицу времени. Затем к вычислению метода приступает второй поток, и т.д.
> public static synchronized void increment() {counter++} 

### Monitor
Монитор - сущность\механизм, благодаря которому достигается корректная работа при синхронизации;
В java у каждого класса и объекта есть свой монитор.

### DEAD LOCK
Ситуация, когда два потока залочены навсегда, ожидают друг друга и ничего не делают.

### LIVE LOCK
Ситуация, когда два потока залочены навсегда, ожидают друг друга, выполняют работу, но без прогресса.



## Methods
* start()
* .setPriority(int);
* .getName
* .sleep(миллисекунды) 
* .join()  тот поток, в котором вызван этот метод, будет ждать завершения указанного потока, напр. thread1.join()
  вызванный в методе main сообщает потоку main, что он должен дождаться завершения thread1
* .join(миллисекунды)  поток продолжит свою работу по истечении времени, указанном в параметре метода
* thread.getState()  -  состояние потока
* synchronized(object)  - синхронизация по объекту