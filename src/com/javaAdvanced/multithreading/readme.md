## Многопоточность -
принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.

### основные цели:
- производительность
- concurrency

### создание 
// создание вариант 1
> class AppThread1 extends Thread{ public void run() {код} }
> 
// запуск
> appThread1.start();
>
метод run() запускается автоматически посредством JVM, при вызове метода start()

// создание вариант 2
> class AppThread implements Runnable { public void run() {код} }
>
// запуск
> new Thread(new Runnable()).start();

### методы .getName() & .getPriority()
Стандартный приоритет потока - 5;  (градация от 1 до 10); 
10 - наивысший приоритет;
установить приоритет можно вручную:
- .setPriority(10);
- .setPriority(Thread.NORM_PRIORITY);


### volatile
Каждый поток работает независимо от других. При обработке данных поток копирует переменные в **CASH-CPU** (речь о
разных ядрах процессора);  
Переменная, отмеченная ключевым словом **volatile** попадает (ее значение) в общую память процессора (Main Memory);  
Корректно переменная с **volatile** работает только в том случае, если изменяет ее строго один из потоков, а остальные
лишь читают переменную;

### Data Race & synchronized methods
Когда несколько потоков имеют доступ к изменению значения переменной, то на выходе почти всегда будет неверный результат;
Это связано с разной скоростью потоков и невозможностью это спрогнозировать. Чтобы избежать ошибок, необходимо
синхронизировать потоки относительно друг друга (поставить LOCK); Функция замка в том, чтобы давать доступ к методу
**только** для одного потока в единицу времени. Затем к вычислению метода приступает второй поток, и т.д.
> public static synchronized void increment() {counter++} 

### Monitor
Монитор - сущность\механизм, благодаря которому достигается корректная работа при синхронизации;
В java у каждого класса и объекта есть свой монитор.

### DEAD LOCK
Ситуация, когда два потока залочены навсегда, ожидают друг друга и ничего не делают.

### LIVE LOCK
Ситуация, когда два потока залочены навсегда, ожидают друг друга, выполняют работу, но без прогресса.

### java.util.concurrent.locks.Lock / ReentrantLock
Выполняет те же задачи, что и synchronized, но другими способами.
В блоке try/catch/finally  ставится lock (объект класса ReentrantLock) позволяя потоку занять монитор и не допуская
другие потоки к работе. После завершения работы потока срабатывает метод **.unlock()**, которые открывает замок, 
разрешая другому потоку приняться за работу.


### DAEMON Thread
Поток в режиме демона работает в фоновом режиме. Это значит, что его работа автоматически прекратится после 
завершения юзер-потоков; Важно вызвать метод .setDaemon(true) перед тем как поток будет запущен, иначе 
сгенерируется исключение; 

### Прерывание потоков
метод **.interrupt()** дает сигнал потоку, что его хотят прервать; Метод `if (**isInterrupted**()){code}`  позволяет потоку 
проверить, хотят ли его прервать; Дальнейшую логику прерывания необходимо писать самостоятельно, она может быть разной
в зависимости от задач программы;


### ThreadPool
ThreadPool - множество потоков, каждый из которых предназначен для той или иной задачи; 
В java, с thread pull удобнее всего работать посредством **ExecutorService**;
Thread pull удобнее всего создавать, используя factory методы класса **Executors**;
Метод **.awaitTermination()** заставляет ждать поток, в котором он объявлен либо окончания указанного в параметрах времени, 
либо завершения работы тред-пула;

### ThreadPool и ScheduledExecutorService
Если стоит задача спланировать время старта потока или его периодичность, на помощь приходит
интерфейс _ScheduledExecutorService_ расширяющий _ExecutorService_;
* .schedule() - позволяет задать в параметрах время, перед стартом выполнения потока;
* .scheduleAtFixedRate - используется для цикличного выполнения заданий в потоке, в параметрах задается время 
между стартом заданий;
* .scheduleWithFixedDelay - параметр delay означает время между окончанием задания и началом нового(повторного);
* `ExecutorService executorService = Executors.newCachedThreadPool()` - создание кэшированного тред-пула, который будет
увеличивать количество потоков автоматически, в зависимости от входящих заданий; (необходимо почитать подробнее)

### Интерфейсы Callable и Future
интерфейс **Callable<V>**; метод  `public V call() throws Exception {}` отличается тем, что его метод 
**.call()** возвращает значение типа V и выбрасывает исключение (в тех случаях, когда необходимо);
* Метод **.get()** блокирует поток в котором был вызван, до завершения задания, чтобы суметь вернуть результат в объект
Future<Integer> future;
* Метод **.isDone()** - позволяет получить статус о выполнении в определенный момент.
* Метод **.submit()** аналогичен методу **execute()**, но возвращает результат метода в объект типа Future;

### Синхронизатор Semaphore
Синхронизатор позволяет ограничить доступ к какому-то ресурсу. В конструктор Semaphore нужно передавать количество
потоков, которым он будет разрешать одновременно использовать этот ресурс.
Внутри Semaphore есть счетчик, регулирующий количество потоков, которым разрешена одновременная работа.
* `semaphore.acquire()`  получает разрешение от семафора на его блокировку
* `semaphore.release()`   освобождаем разрешение семафора, давая возможность работы след. потокам;

### Синхронизатор CountDownLatch
* метод `countDownLatch.await()` - Заставляет текущий поток ждать, пока latch не дойдет до нуля, если только поток
не будет прерван. Если текущий счетчик равен нулю, этот метод немедленно возвращает значение.
Если текущий счетчик больше нуля, то текущий поток становится отключенным для целей планирования потоков
и остается бездействующим.
* метод `.getCount()` работает соответственно названию;

### Синхронизатор Exchanger
**Exchanger** позволяет потокам обмениваться информацией и получать ее одновременно;
метод `exchanger.exchange(T)` блокирует поток, пока его информацией не завладеет другой поток; 
тип **point exchange** определяется в дженериках класса;

### Класс AtomicInteger
**AtomicInteger** - класс, который позволяет работать с целочисленными значениями int, используя атомарные операции;
Имеет в арсенале много методов, некоторые из них:
* .incrementAndGet();
* .addAndGet(5);
* .decrementAndGet();


### ConcurrentHashMap
`ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();`
**ConcurrentHashMap** имплементирует интерфейс _ConcurrentMap_, который наследуется от _Map_; 
ConcurrentHashMap делит map на сегменты (по количеству бакетов), и предоставляет доступ к коллекции всем потокам 
одновременно, НО в каждый сегмент единовременно имеет доступ только один поток. Когда поток выполнил работу с определенным
сегментом, блок снимается и с этим сегментом начинает работу следующий поток.
Таким образом достигается неплохая производительность, выше чем у _synchronizedMap_;

Любое количество потоков может читать информацию из сегментов.


## Methods
* .start()
* .setPriority(int);
* .getName()
* .setName()
* .sleep(миллисекунды) 
* .join()  тот поток, в котором вызван этот метод, будет ждать завершения указанного потока, напр. thread1.join()
  вызванный в методе main сообщает потоку main, что он должен дождаться завершения thread1;
* .join(миллисекунды)  поток продолжит свою работу по истечении времени, указанном в параметре метода
* .thread.getState()  -  состояние потока
* .synchronized(object)  - синхронизация по объекту
* .lock()
* .unlock()
* .tryLock() -> boolean (используется в блоке if), если потоку удалось установить замок, то он выполнит код в блоке 
   try{}, а если нет, то выполнит код раздела else{};
* Thread.currentThread().getName() 
* .setDaemon(true/false)
* .isDaemon()   - проверить статус режима демона;
* .interrupt()
* if (isInterrupted()){code}
* .schedule()
* .scheduleAtFixedRate
* .scheduleWithFixedDelay